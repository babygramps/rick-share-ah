# Couple can be:
# - Created/updated by owner (partner1)
# - Read by any authenticated user (to find by invite code)
# - Updated by partner2 when joining (via owner field update)
type Couple @model @auth(rules: [
  { allow: owner },
  { allow: private, operations: [read] }
]) {
  id: ID!
  name: String!
  partner1Id: String!
  partner1Name: String!
  partner1Email: String!
  partner2Id: String
  partner2Name: String
  partner2Email: String
  inviteCode: String @index(name: "byInviteCode")
  defaultSplitPercent: Int!
  expenses: [Expense] @hasMany
  settlements: [Settlement] @hasMany
}

# Expenses: owner can do everything, but we need both partners to access
# Using private for now - both authenticated partners can read/write
type Expense @model @auth(rules: [
  { allow: owner },
  { allow: private, operations: [read, create, update, delete] }
]) {
  id: ID!
  coupleId: ID! @index(name: "byCouple")
  couple: Couple @belongsTo(fields: ["coupleId"])
  description: String!
  amount: Int!
  paidBy: String!
  splitType: String!
  partner1Share: Int!
  partner2Share: Int!
  category: String!
  date: AWSDate!
  note: String
}

# Settlements: same auth as expenses
type Settlement @model @auth(rules: [
  { allow: owner },
  { allow: private, operations: [read, create, update, delete] }
]) {
  id: ID!
  coupleId: ID! @index(name: "byCouple")
  couple: Couple @belongsTo(fields: ["coupleId"])
  amount: Int!
  paidBy: String!
  paidTo: String!
  date: AWSDate!
  note: String
}